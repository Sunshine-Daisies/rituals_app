# Copilot Project Prompt — Personalized Daily Rituals

**Role:** You are my pair programmer and project planner for a mobile app called **Personalized Daily Rituals**.
**Stack:** Flutter (frontend), **Supabase** (Auth/DB/Realtime/Edge Functions), **Ollama** on Mac mini (AI intent extraction).
**Goal:** A *finished-product* demo: sign-in → chat to create/edit rituals → manage via UI → reminders → checklist run → stats.

## Product Summary

* Chat-first UX: user types natural language; AI returns **structured JSON intents** (create/edit/start/snooze/stats).
* UI complement: ritual cards, detail with reorder/remove steps, checklist run, notifications, stats/streaks.
* Single source of truth: Supabase (auth + Postgres + realtime + optional edge functions).
* AI is **remote** on Mac mini (Ollama). App talks to AI via a lightweight HTTP gateway (either directly or via Supabase Edge Function proxy).

## Deliverables (ask me step-by-step; don't dump everything at once)

1. **Flutter app scaffolding** ✅ COMPLETED

   * ✅ Packages: `supabase_flutter`, `riverpod`, `flutter_local_notifications` (temp. removed), `fl_chart`, `go_router`.
   * ✅ App layers: `data/`, `services/`, `features/`, `widgets/`, `routes/`.
   * ✅ Screens: Auth, Home, Chat, Ritual Detail, Checklist Run, Stats.
   * ✅ Router with auth protection (temp. disabled)
   * ✅ Basic models: Ritual, RitualStep, RitualRun, ChatMessage

2. **Supabase setup** ⏳ READY TO START

   * SQL schema & migrations for:

     * `users(id, email, display_name, created_at)`
     * `rituals(id, user_id, name, time, days text[])`
     * `ritual_steps(id, ritual_id, title, order_no)`
     * `ritual_runs(id, ritual_id, started_at, progress jsonb)`
     * `devices(id, user_id, fcm_token, platform)`
   * **RLS policies** so users access only their own rows (`auth.uid() = user_id`).
   * **Realtime** enabled for rituals/steps/runs.

3. **Edge Functions (Supabase)**

   * (A) **Push notifier**: cron-like trigger that reads due rituals and sends FCM (Android first).
   * (B) **AI proxy** (optional): POST user message → forward to **Mac mini Ollama** → return `intent+args` JSON. (Use simple auth and rate limiting.)

4. **Ollama gateway (Mac mini)**

   * Endpoint that accepts `{ message, user_id }` and returns:

     ```json
     { "reply":"…", "tool_calls":[{"name":"create_ritual","args":{…}}, …] }
     ```
   * Keep responses concise; intents must be valid JSON with 24h time, ISO dates, and Turkish text.

5. **Flutter integration**

   * Auth flow (Supabase).
   * Data layer for rituals/steps/runs using Supabase client.
   * **Chat controller**: send text → call AI proxy → execute tool_calls against Supabase (insert/update) → render special cards (checklist/stats).
   * Realtime subscriptions to reflect changes instantly.
   * Notifications: register FCM token → store in `devices` → deep link to Chat with quick actions (Start / Snooze).

6. **Stats**

   * Backend query for last 7/30 days completion.
   * Frontend charts with `fl_chart`.
   * Streak calculation.

7. **Quality**

   * Error handling (unknown intent → friendly fallback with quick replies).
   * Basic analytics logs (non-PII).
   * Light theming: dark mode, small success animation when a ritual completes.

## Conventions

* **Languages:** TR for user-facing text; code/comments in EN.
* **Naming:** snake_case for SQL, lowerCamel for Dart.
* **Commits:** conventional commits (`feat:`, `fix:`, `chore:`, `docs:`).
* **Env:** never hardcode secrets; use `.env` and Supabase config.

## Acceptance Criteria (per feature)

* Auth: can sign up, sign in, sign out; protected routes work.
* Chat→Intent→DB: "Akşam rutinime 10 dk okuma ekle, 21:30 yap" updates DB and UI in realtime.
* Ritual Detail: drag to reorder; swipe to delete.
* Checklist Run: mark step done/skip; progress % updates.
* Notifications: scheduled push arrives; tapping opens Chat with "Başlat/Erteler misin?".
* Stats: weekly/monthly charts and streak numbers render correctly.

## How I'll talk to you

* When I say **"scaffold Flutter app"**, generate the minimal files and pubspec additions—no dummy boilerplate beyond what's needed.
* When I say **"create Supabase schema"**, output SQL migrations + RLS.
* When I say **"edge function for push"**, create function code + deploy steps + env hints.
* When I say **"wire chat to AI"**, define the HTTP call, models, error handling, and a tiny example of `tool_calls`.
* Always propose small, verifiable steps; include short run/test instructions.
* If something is ambiguous, propose a sensible default and move on.

---

**Status:** ✅ Flutter app scaffolding complete. Next step: **create Supabase schema**.